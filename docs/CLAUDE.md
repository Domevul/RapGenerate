# CLAUDE.md

このファイルは、Claude Code (claude.ai/code) がこのリポジトリで作業する際のガイドを提供します。

## コマンド

### 開発
```bash
npm run dev    # 開発サーバー起動 (http://localhost:3000)
npm run build  # プロダクション用ビルド
npm run start  # プロダクションサーバー起動
npm run lint   # ESLint実行
```

### TypeScript
```bash
npx tsc --noEmit  # ファイル出力なしの型チェック
```

## アーキテクチャ概要

### ゲームコンセプト
MC BATTLEはラップバトルのワード選択型ゲームで、以下の3要素を組み合わせています：
- **ライミングチェーン**（連鎖）: 同じライミンググループの連続使用でボーナス倍率
- **タイプ相性**: 敵のタイプに対するじゃんけん的な相性マッチング
- **リズムゲーム**: フィラーワードのタップタイミング精度

ゲームフロー: タイトル → デッキ選択（15-20コロケーション） → バトルループ（敵ターン → 準備フェーズ → 攻撃フェーズ → 結果） → 最終結果

### 状態管理アーキテクチャ
- **単一Zustandストア** (`lib/store.ts`): 全ゲーム状態を一元管理
- **画面ベースのステートマシン**: `currentScreen`で`app/page.tsx`のレンダリングを制御
- **リソース管理**: `remainingCollocations`で使用済みコロケーションを追跡（バトル中は再使用不可）

主要な状態フロー:
```
setScreen() → UI遷移
startGame() → 残りコロケーション初期化
generateEnemyTurn() → ヒント付き敵ターン情報生成
proceedToPlayerPrepare() → スロット＆フィラー結果リセット
selectCollocationForSlot() → 4コロケーション組み合わせ構築
proceedToAttack() → リズムゲームフェーズ実行
finishAttackPhase() → スコア計算、リソース更新
proceedToNextTurn() → ターン進行またはゲーム終了
```

### ゲームロジックの分離
コア計算は`lib/game-logic.ts`に分離されています：
- **ライミングチェーン評価**: 同一ライミンググループの最大使用回数をカウント、倍率適用（1x→1.5x→2x→3x→4x）
- **タイプ相性**: プレイヤーの主要タイプと敵タイプを`TYPE_COMPATIBILITY_TABLE`でチェック
- **リズム評価**: タップ判定（Perfect/Good/Bad/Miss）をスコアに変換
- **スコア合成**: 重み付き平均（リズム25%、ライミング45%、タイプ30%）

### データアーキテクチャ
- `lib/collocations-data.ts`: 32コロケーション（4ライミンググループ × 各8個、4タイプ分散配置）
- `lib/fillers-data.ts`: 短いフィラーワード（"ya"、"エイ"）をコロケーション間に自動挿入
- `lib/enemy-data.ts`: 事前構築デッキを持つ敵キャラクター
- `lib/constants.ts`: 調整可能な全ゲームパラメータ（ターン数、フェーズ時間、スコア重み、倍率）

### スクリーンコンポーネントのパターン
`components/screens/`の各画面は以下のパターンに従います：
1. セレクタを使って関連するZustand状態を購読
2. useStateでローカルUI状態を実装（タイマー、アニメーション）
3. ユーザー操作でストアアクションを呼び出し
4. 条件を満たしたらuseEffectで自動進行

重要な実装詳細：
- **Battle Prepare**: 8秒タイマー、4スロット埋まるか時間切れで自動進行
- **Battle Attack**: コロケーション＆フィラーのシーケンス、タイミングマーカー付き、重複フィラータップ防止
- **リソース枯渇**: 残りコロケーション < 4の場合、プレイヤーは全スロットを埋められない（適切に処理）

### 型システム
`lib/types.ts`で定義：
- **ゲーム画面**: ステートマシン用のユニオン型（`"title" | "deck-select" | ...`）
- **コロケーション**: `{ id, text, type, rhyming }`、4タイプと4ライミンググループ
- **ターン状態**: `SelectedTurnCollocations`（4スロット）、`FillerTapResult[]`、`TurnResult`
- **評価結果**: リズム/ライミング/タイプ評価結果用の個別インターフェース

## 重要なルール

### 実装プロセス
1. **必ず最初に仕様書を読む**: `SPECIFICATION.md`、`CODING_RULES.md`、`TUTORIAL_SPECIFICATION.md`（チュートリアル関連の場合）
2. **ハードコード前に定数を確認**: 全ゲームパラメータは`lib/constants.ts`に
3. **ストアアクションを使用、直接状態変更しない**: ストア定義外でZustand状態を変更しない
4. **リソース追跡を維持**: コロケーション使用時は必ず`updateRemainingCollocations()`を呼び出す

### コードスタイル（CODING_RULES.mdより）
- **コンポーネント**: 関数宣言（アロー関数不可）、PascalCase、名前付きエクスポート（page.tsx除く）
- **型**: オブジェクトにはinterface、ユニオン/インターセクションにはtype、Propsはtypeを使用
- **"use client"**: フック、インタラクティブ機能、ブラウザAPIを使うコンポーネントに必須
- **スタイリング**: Tailwindクラス、条件付きクラスには`cn()`ヘルパー
- **anyを使わない**: 明示的な型付け必須、非null断言（`!`）を避ける

### Reactベストプラクティス
- **useEffect依存配列**: 完全かつ正確であること（よくあるバグの原因）
- **Hooksはトップレベル**: 条件分岐内に置かない
- **イベントハンドラ**: `handle`で始める（handleClick、handleSubmit）
- **Zustandセレクタ**: 狭いセレクタを使って不要な再レンダリングを避ける

### バグが起きやすい箇所（過去の修正より）
1. **フィラータップ重複**: シーケンス追跡で同じフィラーの重複タップを防止
2. **タイマー自動進行**: タイマーが0に達したらuseEffectで遷移関数を呼び出す必要あり
3. **リソース枯渇**: 準備フェーズ前に`remainingCollocations.length >= 4`をチェック
4. **useEffectループ**: 敵ターン生成は`currentEnemyTurnInfo`の変更で再トリガーしないこと
5. **型安全性**: `!`断言の代わりに、データ欠落時にthrowするヘルパー関数を使用

### ゲームバランスメモ
- 32コロケーション合計: ライミング9A/8B/7C/8D、タイプ12攻撃/10自慢/6夢中/8カウンター
- バトルは2ターン（MVP版）、150+点で勝利（ターンあたり最大100点、リズム/ライミング/タイプで重み付け）
- 敵はバランス型デッキ使用、ヒントは雰囲気+ライミング表示（正確なタイプは非表示）
- フィラータップタイミングは寛容（スコアの30%、主要要素ではない）

## プロジェクト背景

これは日本語のラップバトルゲームMVP版です。コアループは機能していますが、以下の拡張可能性があります：
- 異なるプレイスタイルを持つ複数の敵キャラクター
- より大きなコロケーションプールとデッキカスタマイズ
- チュートリアルシステム（TUTORIAL_SPECIFICATION.mdに一部仕様あり）
- コンボタイマー、難易度設定などの高度な機能

このゲームは純粋なリズムゲームスキルよりも、**戦略的リソース管理**（ライミングチェーン）と**戦術的タイプマッチング**を重視しています。
